
#ifndef __OPCODES__
#define __OPCODES__

#include <string>
#include <vector>
#include <unordered_map>
#include <unordered_set>

#include "misc.h"

// Mask of all possible "identity" bits
constexpr uint32_t I_MASK = 0xfd00707f;

// Mask for just opcode bits
constexpr uint32_t O_MASK = 0x7f;

// Masks for funct3 and funct7 fields
constexpr uint32_t F3_MASK = 0x7000;
constexpr uint32_t F7_MASK = 0xfe000000;

constexpr uint32_t RD_MASK = 0xF80;
constexpr uint32_t R1_MASK = 0xF8000;
constexpr uint32_t R2_MASK = 0x1F00000;
constexpr uint32_t IMM_I_MASK = 0xFFF00000;
constexpr uint32_t IMM_S_MASK = 0xFE000F80;
constexpr uint32_t IMM_U_MASK = 0xFFFFF000;

std::unordered_map<std::string, uint32_t> OPCODES = {
    {"lb", 0b00000000000000000000000000000011},
    {"fmadd.s", 0b00000000000000000000000000000111},
    {"sb", 0b00000000000000000000000000001011},
    {"beq", 0b00000000000000000000000000001111},
    {"addi", 0b00000000000000000000000000010011},
    {"fadd.s", 0b00000000000000000000000000010111},
    {"add", 0b00000000000000000000000000011011},
    {"fnmsub.s", 0b00000000000000000000000000100111},
    {"jal", 0b00000000000000000000000001000011},
    {"fmsub.s", 0b00000000000000000000000001000111},
    {"jalr", 0b00000000000000000000000001001111},
    {"auipc", 0b00000000000000000000000001010011},
    {"lui", 0b00000000000000000000000001011011},
    {"fence", 0b00000000000000000000000001100011},
    {"fnmadd.s", 0b00000000000000000000000001100111},
    {"lbu", 0b00000000000000000001000000000011},
    {"blt", 0b00000000000000000001000000001111},
    {"xori", 0b00000000000000000001000000010011},
    {"xor", 0b00000000000000000001000000011011},
    {"lw", 0b00000000000000000010000000000011},
    {"sw", 0b00000000000000000010000000001011},
    {"slti", 0b00000000000000000010000000010011},
    {"slt", 0b00000000000000000010000000011011},
    {"flw", 0b00000000000000000010000001000011},
    {"fsw", 0b00000000000000000010000001001011},
    {"bltu", 0b00000000000000000011000000001111},
    {"ori", 0b00000000000000000011000000010011},
    {"or", 0b00000000000000000011000000011011},
    {"lh", 0b00000000000000000100000000000011},
    {"sh", 0b00000000000000000100000000001011},
    {"bne", 0b00000000000000000100000000001111},
    {"slli", 0b00000000000000000100000000010011},
    {"sll", 0b00000000000000000100000000011011},
    {"fence.i", 0b00000000000000000100000001100011},
    {"lhu", 0b00000000000000000101000000000011},
    {"bge", 0b00000000000000000101000000001111},
    {"srli", 0b00000000000000000101000000010011},
    {"srl", 0b00000000000000000101000000011011},
    {"sltiu", 0b00000000000000000110000000010011},
    {"sltu", 0b00000000000000000110000000011011},
    {"bgeu", 0b00000000000000000111000000001111},
    {"andi", 0b00000000000000000111000000010011},
    {"and", 0b00000000000000000111000000011011},
    {"sub", 0b00000100000000000000000000011011},
    {"sra", 0b00000100000000000101000000011011},
    {"srai", 0b00001000000000000101000000010011},
    {"fcvt.w.s", 0b00011000000000000000000000010111},
    {"fcvt.wu.s", 0b00011001000000000000000000010111},
    {"fsgnj.s", 0b00100000000000000000000000010111},
    {"fsgnjx.s", 0b00100000000000000010000000010111},
    {"fsgnjn.s", 0b00100000000000000100000000010111},
    {"fle.s", 0b00101000000000000000000000010111},
    {"feq.s", 0b00101000000000000010000000010111},
    {"flt.s", 0b00101000000000000100000000010111},
    {"fmv.x.w", 0b00111000000000000000000000010111},
    {"fclass.s", 0b00111000000000000100000000010111},
    {"fmul.s", 0b01000000000000000000000000010111},
    {"fcvt.s.w", 0b01011000000000000000000000010111},
    {"fcvt.s.wu", 0b01011001000000000000000000010111},
    {"fmv.w.x", 0b01111000000000000000000000010111},
    {"fsub.s", 0b10000000000000000000000000010111},
    {"mul", 0b10000000000000000000000000011011},
    {"div", 0b10000000000000000001000000011011},
    {"mulhsu", 0b10000000000000000010000000011011},
    {"rem", 0b10000000000000000011000000011011},
    {"mulh", 0b10000000000000000100000000011011},
    {"divu", 0b10000000000000000101000000011011},
    {"mulhu", 0b10000000000000000110000000011011},
    {"remu", 0b10000000000000000111000000011011},
    {"fmin.s", 0b10100000000000000000000000010111},
    {"fmax.s", 0b10100000000000000100000000010111},
    {"fdiv.s", 0b11000000000000000000000000010111},
    {"fsqrt.s", 0b11010000000000000000000000010111},
};

std::unordered_map<uint32_t, std::string> INSTRUCTIONS = {
    {0b00000000000000000000000000000011, "lb"},
    {0b00000000000000000000000000000111, "fmadd.s"},
    {0b00000000000000000000000000001011, "sb"},
    {0b00000000000000000000000000001111, "beq"},
    {0b00000000000000000000000000010011, "addi"},
    {0b00000000000000000000000000010111, "fadd.s"},
    {0b00000000000000000000000000011011, "add"},
    {0b00000000000000000000000000100111, "fnmsub.s"},
    {0b00000000000000000000000001000011, "jal"},
    {0b00000000000000000000000001000111, "fmsub.s"},
    {0b00000000000000000000000001001111, "jalr"},
    {0b00000000000000000000000001010011, "auipc"},
    {0b00000000000000000000000001011011, "lui"},
    {0b00000000000000000000000001100011, "fence"},
    {0b00000000000000000000000001100111, "fnmadd.s"},
    {0b00000000000000000001000000000011, "lbu"},
    {0b00000000000000000001000000001111, "blt"},
    {0b00000000000000000001000000010011, "xori"},
    {0b00000000000000000001000000011011, "xor"},
    {0b00000000000000000010000000000011, "lw"},
    {0b00000000000000000010000000001011, "sw"},
    {0b00000000000000000010000000010011, "slti"},
    {0b00000000000000000010000000011011, "slt"},
    {0b00000000000000000010000001000011, "flw"},
    {0b00000000000000000010000001001011, "fsw"},
    {0b00000000000000000011000000001111, "bltu"},
    {0b00000000000000000011000000010011, "ori"},
    {0b00000000000000000011000000011011, "or"},
    {0b00000000000000000100000000000011, "lh"},
    {0b00000000000000000100000000001011, "sh"},
    {0b00000000000000000100000000001111, "bne"},
    {0b00000000000000000100000000010011, "slli"},
    {0b00000000000000000100000000011011, "sll"},
    {0b00000000000000000100000001100011, "fence.i"},
    {0b00000000000000000101000000000011, "lhu"},
    {0b00000000000000000101000000001111, "bge"},
    {0b00000000000000000101000000010011, "srli"},
    {0b00000000000000000101000000011011, "srl"},
    {0b00000000000000000110000000010011, "sltiu"},
    {0b00000000000000000110000000011011, "sltu"},
    {0b00000000000000000111000000001111, "bgeu"},
    {0b00000000000000000111000000010011, "andi"},
    {0b00000000000000000111000000011011, "and"},
    {0b00000100000000000000000000011011, "sub"},
    {0b00000100000000000101000000011011, "sra"},
    {0b00001000000000000101000000010011, "srai"},
    {0b00011000000000000000000000010111, "fcvt.w.s"},
    {0b00011001000000000000000000010111, "fcvt.wu.s"},
    {0b00100000000000000000000000010111, "fsgnj.s"},
    {0b00100000000000000010000000010111, "fsgnjx.s"},
    {0b00100000000000000100000000010111, "fsgnjn.s"},
    {0b00101000000000000000000000010111, "fle.s"},
    {0b00101000000000000010000000010111, "feq.s"},
    {0b00101000000000000100000000010111, "flt.s"},
    {0b00111000000000000000000000010111, "fmv.x.w"},
    {0b00111000000000000100000000010111, "fclass.s"},
    {0b01000000000000000000000000010111, "fmul.s"},
    {0b01011000000000000000000000010111, "fcvt.s.w"},
    {0b01011001000000000000000000010111, "fcvt.s.wu"},
    {0b01111000000000000000000000010111, "fmv.w.x"},
    {0b10000000000000000000000000010111, "fsub.s"},
    {0b10000000000000000000000000011011, "mul"},
    {0b10000000000000000001000000011011, "div"},
    {0b10000000000000000010000000011011, "mulhsu"},
    {0b10000000000000000011000000011011, "rem"},
    {0b10000000000000000100000000011011, "mulh"},
    {0b10000000000000000101000000011011, "divu"},
    {0b10000000000000000110000000011011, "mulhu"},
    {0b10000000000000000111000000011011, "remu"},
    {0b10100000000000000000000000010111, "fmin.s"},
    {0b10100000000000000100000000010111, "fmax.s"},
    {0b11000000000000000000000000010111, "fdiv.s"},
    {0b11010000000000000000000000010111, "fsqrt.s"},
};

std::unordered_set<uint32_t> FUNCT7_OPS = {
    0b00000000000000000000000000000111 & O_MASK,
    0b00000000000000000000000000010111 & O_MASK,
    0b00000000000000000000000000011011 & O_MASK,
    0b00000000000000000000000000100111 & O_MASK,
    0b00000000000000000000000001000111 & O_MASK,
    0b00000000000000000000000001100111 & O_MASK,
    0b00000000000000000001000000011011 & O_MASK,
    0b00000000000000000010000000011011 & O_MASK,
    0b00000000000000000011000000011011 & O_MASK,
    0b00000000000000000100000000010011 & O_MASK,
    0b00000000000000000100000000011011 & O_MASK,
    0b00000000000000000101000000010011 & O_MASK,
    0b00000000000000000101000000011011 & O_MASK,
    0b00000000000000000110000000011011 & O_MASK,
    0b00000000000000000111000000011011 & O_MASK,
    0b00000100000000000000000000011011 & O_MASK,
    0b00000100000000000101000000011011 & O_MASK,
    0b00001000000000000101000000010011 & O_MASK,
    0b00011000000000000000000000010111 & O_MASK,
    0b00011001000000000000000000010111 & O_MASK,
    0b00100000000000000000000000010111 & O_MASK,
    0b00100000000000000010000000010111 & O_MASK,
    0b00100000000000000100000000010111 & O_MASK,
    0b00101000000000000000000000010111 & O_MASK,
    0b00101000000000000010000000010111 & O_MASK,
    0b00101000000000000100000000010111 & O_MASK,
    0b00111000000000000000000000010111 & O_MASK,
    0b00111000000000000100000000010111 & O_MASK,
    0b01000000000000000000000000010111 & O_MASK,
    0b01011000000000000000000000010111 & O_MASK,
    0b01011001000000000000000000010111 & O_MASK,
    0b01111000000000000000000000010111 & O_MASK,
    0b10000000000000000000000000010111 & O_MASK,
    0b10000000000000000000000000011011 & O_MASK,
    0b10000000000000000001000000011011 & O_MASK,
    0b10000000000000000010000000011011 & O_MASK,
    0b10000000000000000011000000011011 & O_MASK,
    0b10000000000000000100000000011011 & O_MASK,
    0b10000000000000000101000000011011 & O_MASK,
    0b10000000000000000110000000011011 & O_MASK,
    0b10000000000000000111000000011011 & O_MASK,
    0b10100000000000000000000000010111 & O_MASK,
    0b10100000000000000100000000010111 & O_MASK,
    0b11000000000000000000000000010111 & O_MASK,
    0b11010000000000000000000000010111 & O_MASK,
};

std::unordered_set<uint32_t> FUNCT3_OPS = {
    0b00000000000000000000000000000011 & O_MASK,
    0b00000000000000000000000000001011 & O_MASK,
    0b00000000000000000000000000001111 & O_MASK,
    0b00000000000000000000000000010011 & O_MASK,
    0b00000000000000000000000000011011 & O_MASK,
    0b00000000000000000000000001001111 & O_MASK,
    0b00000000000000000000000001100011 & O_MASK,
    0b00000000000000000001000000000011 & O_MASK,
    0b00000000000000000001000000001111 & O_MASK,
    0b00000000000000000001000000010011 & O_MASK,
    0b00000000000000000001000000011011 & O_MASK,
    0b00000000000000000010000000000011 & O_MASK,
    0b00000000000000000010000000001011 & O_MASK,
    0b00000000000000000010000000010011 & O_MASK,
    0b00000000000000000010000000011011 & O_MASK,
    0b00000000000000000010000001000011 & O_MASK,
    0b00000000000000000010000001001011 & O_MASK,
    0b00000000000000000011000000001111 & O_MASK,
    0b00000000000000000011000000010011 & O_MASK,
    0b00000000000000000011000000011011 & O_MASK,
    0b00000000000000000100000000000011 & O_MASK,
    0b00000000000000000100000000001011 & O_MASK,
    0b00000000000000000100000000001111 & O_MASK,
    0b00000000000000000100000000010011 & O_MASK,
    0b00000000000000000100000000011011 & O_MASK,
    0b00000000000000000100000001100011 & O_MASK,
    0b00000000000000000101000000000011 & O_MASK,
    0b00000000000000000101000000001111 & O_MASK,
    0b00000000000000000101000000010011 & O_MASK,
    0b00000000000000000101000000011011 & O_MASK,
    0b00000000000000000110000000010011 & O_MASK,
    0b00000000000000000110000000011011 & O_MASK,
    0b00000000000000000111000000001111 & O_MASK,
    0b00000000000000000111000000010011 & O_MASK,
    0b00000000000000000111000000011011 & O_MASK,
    0b00000100000000000000000000011011 & O_MASK,
    0b00000100000000000101000000011011 & O_MASK,
    0b00001000000000000101000000010011 & O_MASK,
    0b00100000000000000000000000010111 & O_MASK,
    0b00100000000000000010000000010111 & O_MASK,
    0b00100000000000000100000000010111 & O_MASK,
    0b00101000000000000000000000010111 & O_MASK,
    0b00101000000000000010000000010111 & O_MASK,
    0b00101000000000000100000000010111 & O_MASK,
    0b00111000000000000000000000010111 & O_MASK,
    0b00111000000000000100000000010111 & O_MASK,
    0b01111000000000000000000000010111 & O_MASK,
    0b10000000000000000000000000011011 & O_MASK,
    0b10000000000000000001000000011011 & O_MASK,
    0b10000000000000000010000000011011 & O_MASK,
    0b10000000000000000011000000011011 & O_MASK,
    0b10000000000000000100000000011011 & O_MASK,
    0b10000000000000000101000000011011 & O_MASK,
    0b10000000000000000110000000011011 & O_MASK,
    0b10000000000000000111000000011011 & O_MASK,
    0b10100000000000000000000000010111 & O_MASK,
    0b10100000000000000100000000010111 & O_MASK,
};

std::string identify(uint32_t instruction)
{
    std::vector<uint32_t> options = {};
    uint32_t opcode = instruction & O_MASK;
    if (FUNCT3_OPS.count(opcode))
    { // opcode includes a Funct3 field
        for (auto pair : INSTRUCTIONS)
        {
            if ((pair.first & O_MASK) != opcode)
            { // Only check matching opcodes
                continue;
            }

            if ((pair.first & F3_MASK) == (instruction & F3_MASK))
            { // funct3 fields match
                options.push_back(pair.first);
            }
        }

        if (options.size() == 1)
        { // Only one func3 matched, return identified instruction
            return INSTRUCTIONS[options[0]];
        }
    }

    if (FUNCT7_OPS.count(opcode))
    { // opcode includes a Funct7 field
        for (auto option : options)
        { // funct7 is only needed when funct3 matches multiple opcodes
            if ((option & F7_MASK) == (instruction & F7_MASK))
            { // Only one funct7 should match (it's the only field left to check)
                return INSTRUCTIONS[option];
            }
        }
    }

    // No func3 or funct7 needed
    for (auto pair : INSTRUCTIONS)
    {
        if ((pair.first & O_MASK) == (instruction & O_MASK))
        {
            return pair.second;
        }
    }

    throw std::runtime_error("No keyword could be identified for " + str(instruction));
}

uint32_t singleBitMask(uint8_t index)
{
    return 0xFFFFFFFF ^ (1 << index);
}

uint32_t getBit(uint32_t data, uint8_t index)
{
    return (data & (1 << index));
}

uint32_t setBit(uint32_t data, uint8_t index, bool value)
{
    return (data & ~(1 << index)) | (value << index);
}

uint32_t slice(uint32_t data, uint8_t start, uint8_t end)
{
    uint32_t bits = 0;
    for (int i = start; i >= end; i--)
    {
        bits |= getBit(data, i);
    }

    return bits;
}

uint32_t getRd(uint32_t data)
{
    return (data & RD_MASK) >> 7;
}

uint32_t getR1(uint32_t data)
{
    return (data & R1_MASK) >> 15;
}

uint32_t getR2(uint32_t data)
{
    return (data & R2_MASK) >> 20;
}

uint32_t getImmediateI(uint32_t data)
{
    return (data & IMM_I_MASK) >> 20;
}

uint32_t getImmediateS(uint32_t data)
{
    // Mask and align lsb with overall lsb
    data = (data & IMM_S_MASK) >> 7;

    // Keep properly aligned lsb
    uint32_t bits = slice(data, 4, 0);

    // Align offset 11:5 with 4:0
    bits = slice(data >> 13, 11, 5) | bits;

    return bits;
}

uint32_t getImmediateSB(uint32_t data)
{
    // Start with bringing all bits together
    uint32_t bits = getImmediateS(data);

    // Unscramble the misaligned bits
    // B and C are the hex values for each bit's proper index
    uint32_t B = getBit(bits, 0);
    uint32_t C = getBit(bits, 11) >> 11;

    bits &= singleBitMask(0);    // Clear 0 index
    bits = setBit(bits, 0xB, B); // Set B into index 11
    bits = setBit(bits, 0xC, C); // Set C into index 12

    return bits;
}

#endif // __OPCODES__